## 11. 服务发现：Eureka客户端

服务发现是基于微服务架构的关键原则之一. 尝试配置每个客户端或某种形式的约定可能非常困难，而且非常脆弱. Eureka是Netflix提供的，可以实现服务发现服务器端和客户端的组件. 可以将服务器配置和部署为高可用性，每个服务器将注册服务的状态复制到其他服务器.

## 11.1 如何添加Eureka客户端依赖

要在项目中包含Eureka Client，可以添加group Id为`org.springframework.cloud`和artifact Id 为`spring-cloud-starter-eureka`的起步依赖. 有关使用当前Spring Cloud发布版本设置构建系统的详细信息，请参阅“Spring Cloud Project”页面.

## 注册到Eureka

当一个客户端注册到Eureka时， 它需要提供自已一些元数据信息，比如主机和端口，还有健康检查的URL， 主页等等. Eureka receives heartbeat messages from each instance belonging to a service. 如果在配置的时间段内接收心跳消息失败，这个实例就会从注册中心被正常的移除.

Eureka客户端的例子:

    @Configuration
    @ComponentScan
    @EnableAutoConfiguration
    @EnableEurekaClient
    @RestController
    public class Application {
    
        @RequestMapping("/")
        public String home() {
            return "Hello world";
        }
    
        public static void main(String[] args) {
            new SpringApplicationBuilder(Application.class).web(true).run(args);
        }
    
    }
    

(i.e. utterly normal Spring Boot app). 在这个例子中我们使用@EnableEurekaClient注解，但只有Eureka可以使用@EnableDiscoveryClient注解. 还需要一些配置来定位Eureka服务器. 例如:

**application.yml.**

    eureka:
      client:
        serviceUrl:
          defaultZone: http://localhost:8761/eureka/
    

这里的defaultZone是一个神奇的字符串值， 客户端如果不显式的配置，会使用此默认值（它是非常有用的）.

从环境（Environment）中获取的默认应用程序名称（服务ID）、虚拟主机和非安全端口分别是${spring.application.name}, ${spring.application.name}和${server.port}.

从环境（Environment）中获取的默认应用程序名称（服务ID）、虚拟主机和非安全端口分别是${spring.application.name}, ${spring.application.name}和${server.port}@EnableEurekaClient使应用程序即是一个Eureka实例（它可以自已注册自已） 又一个客户端，（它可以从注册中心查询定位其它服务）. 它的实例的行为由eureka.instance.*配值驱动。但是如果你保证你的程序中有一个spring.application.name（它默认是Euraka的service ID， 或者VIP），那么默认的配值已经很好了.

查看EurekaInstanceConfigBean 和 EurekaClientConfigBean 以获得更多可配置的选项的详细信息.

## 11.3 认证Eureka服务

如果其中一个eureka.client.serviceUrl.defaultZoneURL中嵌入了凭证（如：http://user:password@localhost:8761/eureka），则HTTP基本身份验证将自动添加到您的eureka客户端。. 对于更复杂的需求，您可以创建一个类型为`DiscoveryClientOptionalArgs`的@Bean，并将`ClientFilter`实例注入到其中，所有这些都将应用于从客户端到服务器的调用.

> 由于Eureka的限制，不可能支持每个服务器的基本身份验证凭据，因此只有第一个被找到的被使用.

## 11.4 状态页和健康指标

Eureka实例的状态页面和运行状况指示器，默认情况下分别为“/ info”和“/ health”，它们是Spring Boot Actuator应用程序中有用端点的默认位置. 如果您使用非默认上下文路径或servlet路径（例如server.servletPath = /foo）或管理端点路径（例如management.contextPath = /admin），则需要更改这些，即使是执行程序应用程序. 例:

**application.yml.**

    eureka:
      instance:
        statusPageUrlPath: ${management.context-path}/info
        healthCheckUrlPath: ${management.context-path}/health
    

这些链接显示在客户端的元数据中，并在某些情况下用于决定是否将请求发送到应用程序，因此正确的配置它们是非常有用的.

## 11.5 注册安全的应用程序

如果你的应用程序想要通过HTTPS调用，您可以在EurekaInstanceConfig配置中，通过eureka.instanc.[nonSecurePortEnabled，securePortEnabled] = [false，true]设置两个标志. This will make Eureka publish instance information showing an explicit preference for secure communication. Spring Cloud DiscoveryClient将始终返回一个https://...; 以这种方式配置的服务的URI，以及Eureka（本机）实例信息将具有安全的健康检查URL.

由于Eureka在内部工作的方式，它仍然会发布非安全状态和主页URL，除非你明确地覆盖. You can use placeholders to configure the eureka instance urls, e.g.

**application.yml.**

    eureka:
      instance:
        statusPageUrl: https://${eureka.hostname}/info
        healthCheckUrl: https://${eureka.hostname}/health
        homePageUrl: https://${eureka.hostname}/
    

（注意${eureka.hostname}是仅在最新版本的Eureka中可用的本地占位符. 你也可以使用Spring占位符实现同样的功能，例如使用${eureka.instance.hostName}）

> 默认情况下， Eureka使用客户端的心跳决定一个客户端是否“存活”（“UP”状态），除非特别声明Discovery Client不根据Spring Boot Actuator传播应用程序的当前运行状况检查状态. 这也就是说客户端注册成功后，Eureka将永远宣布应用程序处于“Up”状态。通过启用Eureka的健康检查可以改变这种行为，从而将应用程序状态传播给Eureka. 因此，每个其他应用程序将不会向“Up”状态以外的应用程序发送请求。.

## Eureka的健康检查

默认情况下， Eureka使用客户端的心跳决定一个客户端是否“存活”（“Up”状态）. 除非特别声明Discovery Client不根据Spring Boot Actuator传播应用程序的当前运行状况检查状态. 这也就是说客户端注册成功后，Eureka将永远宣布应用程序处于“UP”状态. 通过启用Eureka的健康检查可以改变这种行为，从而将应用程序状态传播给Eureka. 因此，每个其他应用程序将不会向“UP”状态以外的应用程序发送请求.

**application.yml.**

    eureka:
      client:
        healthcheck:
          enabled: true
    

> `eureka.client.healthcheck.enabled=true`should only be set in `application.yml` . Setting the value in `bootstrap.yml` will cause undesirable side effects like registering in eureka with an`UNKNOWN`status.

如果你想自已控制健康检查， 你可以考虑实现你自已的com.netflix.appinfo.HealthCheckHandler.

## 11.7 服务实例和客户端注册到Eureka的元数据

很值得花一点时间了解Eureka的元数据是如何工作的， 所以你可以在你的平台上使用这些元数据. 有一些标准的元数据比如：IP地址、端口号、状态页和健康检查需要的数据. 它们被发布到注册中心，并且被客户端使用，来直接访问服务提供者. 额外的元素据可以添加到注册实例的eureka.instance.metadataMap中，这些信息可以被远程 的客户端访问， 但是一般不会改变客户端的行为，除非知道元数据的含义. 下面介绍几种特殊情况， Spring Cloud已经为元数据ma赋于了含义.

### 11.7.1 在Cloudfoundry上使用Eureka

Cloudfoundry有一个全局路由器，所以同一个应用程序的所有实例都具有相同的主机名（在具有相似架构的其他PaaS解决方案中也是如此）. 这不一定是使用Eureka的障碍，但是如果您使用路由器（建议，甚至是强制性的，具体取决于您的平台的设置方式），则需要明确设置主机名和端口号（安全或不安全）），以便他们使用路由器. 您可能还需要使用实例元数据，以便您可以区分客户端上的实例（例如，在自定义负载均衡器中）. 默认情况下，eureka.instance.instanceId就是vcap.application.instance_id. 例如:

**application.yml.**

    eureka:
      instance:
        hostname: ${vcap.application.uris[0]}
        nonSecurePort: 80
    

根据Cloudfoundry实例中安全规则的设置方式，您可以注册并使用主机VM的IP地址进行直接的服务到服务调用. 此功能尚未在Pivotal Web Services（PWS）上提供。.

### 11.7.2 在AWS上使用Eureka

如果计划将应用程序部署到AWS云端，则Eureka实例必须配置为AWS感知，这可以通过以下方式定制EurekaInstanceConfigBean来完成:

    @Bean
    @Profile("!default")
    public EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) {
      EurekaInstanceConfigBean b = new EurekaInstanceConfigBean(inetUtils);
      AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild("eureka");
      b.setDataCenterInfo(info);
      return b;
    }
    

### 11.7.3 修改Eureka的Instance ID

Netflix Eureka实例注册了与其主机名相同的ID（即每个主机只有一个服务）. Spring Cloud Eureka提供了一个默认的. 比如：myhost:myappname:8080.

使用Spring Cloud可以通过在eureka.instance.instanceId中提供唯一的标识符来覆盖此方法:

**application.yml.**

    eureka:
      instance:
        instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}
    

With this metadata, and multiple service instances deployed on localhost, the random value will kick in there to make the instance unique. In Cloudfoundry the`vcap.application.instance_id`will be populated automatically in a Spring Boot application, so the random value will not be needed.

## 11.8 Using the EurekaClient

Once you have an app that is `@EnableDiscoveryClient` (or `@EnableEurekaClient`) you can use it to discover service instances rom the[Eureka Server](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi_spring-cloud-eureka-server.html). One way to do that is to use the native `com.netflix.discovery.EurekaClient` (as opposed to the Spring Cloud `DiscoveryClient` ), e.g.

    @Autowired
    private EurekaClient discoveryClient;
    
    public String serviceUrl() {
        InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
        return instance.getHomePageUrl();
    }
    

> Don’t use the`EurekaClient` in `@PostConstruct` method or in a `@Scheduled` method (or anywhere where the`ApplicationContext`might not be started yet). It is initialized in a `SmartLifecycle` (with`phase=0`) so the earliest you can rely on it being available is in another `SmartLifecycle` with higher phase.

## 11.9 Alternatives to the native Netflix EurekaClient

You don’t have to use the raw Netflix `EurekaClient` and usually it is more convenient to use it behind a wrapper of some sort. Spring Cloud has support for [Feign](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi_spring-cloud-feign.html) (a REST client builder) and also [Spring `RestTemplate`](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi_spring-cloud-ribbon.html)using the logical Eureka service identifiers (VIPs) instead of physical URLs. To configure Ribbon with a fixed list of physical servers you can simply set `<client>.ribbon.listOfServers` to a comma-separated list of physical addresses (or hostnames), where`<client>`is the ID of the client.

You can also use the `org.springframework.cloud.client.discovery.DiscoveryClient` which provides a simple API for discovery clients that is not specific to Netflix, e.g.

    @Autowired
    private DiscoveryClient discoveryClient;
    
    public String serviceUrl() {
        List<ServiceInstance> list = discoveryClient.getInstances("STORES");
        if (list != null && list.size() > 0 ) {
            return list.get(0).getUri();
        }
        return null;
    }
    

## 11.10 Why is it so Slow to Register a Service?

Being an instance also involves a periodic heartbeat to the registry (via the client’s `serviceUrl` ) with default duration 30 seconds. A service is not available for discovery by clients until the instance, the server and the client all have the same metadata in their local cache (so it could take 3 heartbeats). You can change the period using `eureka.instance.leaseRenewalIntervalInSeconds` and this will speed up the process of getting clients connected to other services. In production it’s probably better to stick with the default because there are some computations internally in the server that make assumptions about the lease renewal period.

## 11.11 Zones

If you have deployed Eureka clients to multiple zones than you may prefer that those clients leverage services within the same zone before trying services in another zone. To do this you need to configure your Eureka clients correctly.

First, you need to make sure you have Eureka servers deployed to each zone and that they are peers of each other. See the section on[zones and regions](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi_spring-cloud-eureka-server.html#spring-cloud-eureka-server-zones-and-regions)for more information.

Next you need to tell Eureka which zone your service is in. You can do this using the `metadataMap` property. For example if`service 1`is deployed to both `zone 1` and `zone 2` you would need to set the following Eureka properties in `service 1`

**Service 1 in Zone 1**

    eureka.instance.metadataMap.zone = zone1
    eureka.client.preferSameZoneEureka = true
    

**Service 1 in Zone 2**

    eureka.instance.metadataMap.zone = zone2
    eureka.client.preferSameZoneEureka = true