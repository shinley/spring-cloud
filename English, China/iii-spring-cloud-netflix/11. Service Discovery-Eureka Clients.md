## 11. 服务发现：Eureka客户端

服务发现是基于微服务架构的关键原则之一. 尝试配置每个客户端或某种形式的约定可能非常困难，而且非常脆弱. Eureka是Netflix提供的，可以实现服务发现服务器端和客户端的组件. 可以将服务器配置和部署为高可用性，每个服务器将注册服务的状态复制到其他服务器.

## 11.1 如何添加Eureka客户端依赖

要在项目中包含Eureka Client，可以添加group Id为`org.springframework.cloud`和artifact Id 为`spring-cloud-starter-eureka`的起步依赖. 有关使用当前Spring Cloud发布版本设置构建系统的详细信息，请参阅“Spring Cloud Project”页面.

## 注册到Eureka

当一个客户端注册到Eureka时， 它需要提供自已一些元数据信息，比如主机和端口，还有健康检查的URL， 主页等等. Eureka receives heartbeat messages from each instance belonging to a service. 如果在配置的时间段内接收心跳消息失败，这个实例就会从注册中心被正常的移除.

Eureka客户端的例子:

    @Configuration
    @ComponentScan
    @EnableAutoConfiguration
    @EnableEurekaClient
    @RestController
    public class Application {
    
        @RequestMapping("/")
        public String home() {
            return "Hello world";
        }
    
        public static void main(String[] args) {
            new SpringApplicationBuilder(Application.class).web(true).run(args);
        }
    
    }
    

(i.e. utterly normal Spring Boot app). 在这个例子中我们使用@EnableEurekaClient注解，但只有Eureka可以使用@EnableDiscoveryClient注解. 还需要一些配置来定位Eureka服务器. 例如:

**application.yml.**

    eureka:
      client:
        serviceUrl:
          defaultZone: http://localhost:8761/eureka/
    

这里的defaultZone是一个神奇的字符串值， 客户端如果不显式的配置，会使用此默认值（它是非常有用的）.

从环境（Environment）中获取的默认应用程序名称（服务ID）、虚拟主机和非安全端口分别是${spring.application.name}, ${spring.application.name}和${server.port}.

从环境（Environment）中获取的默认应用程序名称（服务ID）、虚拟主机和非安全端口分别是${spring.application.name}, ${spring.application.name}和${server.port}@EnableEurekaClient使应用程序即是一个Eureka实例（它可以自已注册自已） 又一个客户端，（它可以从注册中心查询定位其它服务）. 它的实例的行为由eureka.instance.*配值驱动。但是如果你保证你的程序中有一个spring.application.name（它默认是Euraka的service ID， 或者VIP），那么默认的配值已经很好了.

查看EurekaInstanceConfigBean 和 EurekaClientConfigBean 以获得更多可配置的选项的详细信息.

## 11.3 认证Eureka服务

如果其中一个eureka.client.serviceUrl.defaultZoneURL中嵌入了凭证（如：http://user:password@localhost:8761/eureka），则HTTP基本身份验证将自动添加到您的eureka客户端。. 对于更复杂的需求，您可以创建一个类型为`DiscoveryClientOptionalArgs`的@Bean，并将`ClientFilter`实例注入到其中，所有这些都将应用于从客户端到服务器的调用.

> 由于Eureka的限制，不可能支持每个服务器的基本身份验证凭据，因此只有第一个被找到的被使用.

## 11.4 状态页和健康指标

Eureka实例的状态页面和运行状况指示器，默认情况下分别为“/ info”和“/ health”，它们是Spring Boot Actuator应用程序中有用端点的默认位置. 如果您使用非默认上下文路径或servlet路径（例如server.servletPath = /foo）或管理端点路径（例如management.contextPath = /admin），则需要更改这些，即使是执行程序应用程序. 例:

**application.yml.**

    eureka:
      instance:
        statusPageUrlPath: ${management.context-path}/info
        healthCheckUrlPath: ${management.context-path}/health
    

这些链接显示在客户端的元数据中，并在某些情况下用于决定是否将请求发送到应用程序，因此正确的配置它们是非常有用的.

## 11.5 注册安全的应用程序

如果你的应用程序想要通过HTTPS调用，您可以在EurekaInstanceConfig配置中，通过eureka.instanc.[nonSecurePortEnabled，securePortEnabled] = [false，true]设置两个标志. This will make Eureka publish instance information showing an explicit preference for secure communication. Spring Cloud DiscoveryClient将始终返回一个https://...; 以这种方式配置的服务的URI，以及Eureka（本机）实例信息将具有安全的健康检查URL.

由于Eureka在内部工作的方式，它仍然会发布非安全状态和主页URL，除非你明确地覆盖. You can use placeholders to configure the eureka instance urls, e.g.

**application.yml.**

    eureka:
      instance:
        statusPageUrl: https://${eureka.hostname}/info
        healthCheckUrl: https://${eureka.hostname}/health
        homePageUrl: https://${eureka.hostname}/
    

（注意${eureka.hostname}是仅在最新版本的Eureka中可用的本地占位符. 你也可以使用Spring占位符实现同样的功能，例如使用${eureka.instance.hostName}）

> 默认情况下， Eureka使用客户端的心跳决定一个客户端是否“存活”（“UP”状态），除非特别声明Discovery Client不根据Spring Boot Actuator传播应用程序的当前运行状况检查状态. 这也就是说客户端注册成功后，Eureka将永远宣布应用程序处于“Up”状态。通过启用Eureka的健康检查可以改变这种行为，从而将应用程序状态传播给Eureka. 因此，每个其他应用程序将不会向“Up”状态以外的应用程序发送请求。.

## Eureka的健康检查

默认情况下， Eureka使用客户端的心跳决定一个客户端是否“存活”（“Up”状态）. 除非特别声明Discovery Client不根据Spring Boot Actuator传播应用程序的当前运行状况检查状态. 这也就是说客户端注册成功后，Eureka将永远宣布应用程序处于“UP”状态. 通过启用Eureka的健康检查可以改变这种行为，从而将应用程序状态传播给Eureka. 因此，每个其他应用程序将不会向“UP”状态以外的应用程序发送请求.

**application.yml.**

    eureka:
      client:
        healthcheck:
          enabled: true
    

> eureka.client.healthcheck.enabled=true 只能设置在application.yml配置文件中. 设置在bootstrap.yml中将导致不可预知的问题，比如会导致注册到Eureka中的应用为UNKNOW状态。.

If you require more control over the health checks, you may consider implementing your own

`com.netflix.appinfo.HealthCheckHandler`.

## 11.7 Eureka Metadata for Instances and Clients

It’s worth spending a bit of time understanding how the Eureka metadata works, so you can use it in a way that makes sense in your platform. There is standard metadata for things like hostname, IP address, port numbers, status page and health check. These are published in the service registry and used by clients to contact the services in a straightforward way. Additional metadata can be added to the instance registration in the`eureka.instance.metadataMap`, and this will be accessible in the remote clients, but in general will not change the behaviour of the client, unless it is made aware of the meaning of the metadata. There are a couple of special cases described below where Spring Cloud already assigns meaning to the metadata map.

### 11.7.1 Using Eureka on Cloudfoundry

Cloudfoundry has a global router so that all instances of the same app have the same hostname (it’s the same in other PaaS solutions with a similar architecture). This isn’t necessarily a barrier to using Eureka, but if you use the router (recommended, or even mandatory depending on the way your platform was set up), you need to explicitly set the hostname and port numbers (secure or non-secure) so that they use the router. You might also want to use instance metadata so you can distinguish between the instances on the client (e.g. in a custom load balancer). By default, the`eureka.instance.instanceId`is`vcap.application.instance_id`. For example:

**application.yml.**

    eureka:
      instance:
        hostname: ${vcap.application.uris[0]}
        nonSecurePort: 80
    

Depending on the way the security rules are set up in your Cloudfoundry instance, you might be able to register and use the IP address of the host VM for direct service-to-service calls. This feature is not (yet) available on Pivotal Web Services ([PWS](https://run.pivotal.io/)).Depending on the way the security rules are set up in your Cloudfoundry instance, you might be able to register and use the IP address of the host VM for direct service-to-service calls. This feature is not (yet) available on Pivotal Web Services ([PWS](https://run.pivotal.io/)).

### 11.7.2 Using Eureka on AWS

If the application is planned to be deployed to an AWS cloud, then the Eureka instance will have to be configured to be AWS aware and this can be done by customizing the[EurekaInstanceConfigBean](https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java)the following way:

    @Bean
    @Profile("!default")
    public EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) {
      EurekaInstanceConfigBean b = new EurekaInstanceConfigBean(inetUtils);
      AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild("eureka");
      b.setDataCenterInfo(info);
      return b;
    }
    

### 11.7.3 Changing the Eureka Instance ID

A vanilla Netflix Eureka instance is registered with an ID that is equal to its host name (i.e. only one service per host). Spring Cloud Eureka provides a sensible default that looks like this:`${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}`. For example`myhost:myappname:8080`.

Using Spring Cloud you can override this by providing a unique identifier in`eureka.instance.instanceId`. For example:

**application.yml.**

    eureka:
      instance:
        instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}
    

With this metadata, and multiple service instances deployed on localhost, the random value will kick in there to make the instance unique. In Cloudfoundry the`vcap.application.instance_id`will be populated automatically in a Spring Boot application, so the random value will not be needed.

## 11.8 Using the EurekaClient

Once you have an app that is`@EnableDiscoveryClient`(or`@EnableEurekaClient`) you can use it to discover service instances rom the[Eureka Server](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi_spring-cloud-eureka-server.html). One way to do that is to use the native`com.netflix.discovery.EurekaClient`(as opposed to the Spring Cloud`DiscoveryClient`), e.g.

    @Autowired
    private EurekaClient discoveryClient;
    
    public String serviceUrl() {
        InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
        return instance.getHomePageUrl();
    }
    

> Don’t use the`EurekaClient`in`@PostConstruct`method or in a`@Scheduled`method (or anywhere where the`ApplicationContext`might not be started yet). It is initialized in a`SmartLifecycle`(with`phase=0`) so the earliest you can rely on it being available is in another`SmartLifecycle`with higher phase.

## 11.9 Alternatives to the native Netflix EurekaClient

You don’t have to use the raw Netflix`EurekaClient`and usually it is more convenient to use it behind a wrapper of some sort. Spring Cloud has support for [Feign](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi_spring-cloud-feign.html) (a REST client builder) and also [Spring`RestTemplate`](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi_spring-cloud-ribbon.html)using the logical Eureka service identifiers (VIPs) instead of physical URLs. To configure Ribbon with a fixed list of physical servers you can simply set`<client>.ribbon.listOfServers`to a comma-separated list of physical addresses (or hostnames), where`<client>`is the ID of the client.

You can also use the`org.springframework.cloud.client.discovery.DiscoveryClient`which provides a simple API for discovery clients that is not specific to Netflix, e.g.

    @Autowired
    private DiscoveryClient discoveryClient;
    
    public String serviceUrl() {
        List<ServiceInstance> list = discoveryClient.getInstances("STORES");
        if (list != null && list.size() > 0 ) {
            return list.get(0).getUri();
        }
        return null;
    }
    

## 11.10 Why is it so Slow to Register a Service?

Being an instance also involves a periodic heartbeat to the registry (via the client’s`serviceUrl`) with default duration 30 seconds. A service is not available for discovery by clients until the instance, the server and the client all have the same metadata in their local cache (so it could take 3 heartbeats). You can change the period using`eureka.instance.leaseRenewalIntervalInSeconds`and this will speed up the process of getting clients connected to other services. In production it’s probably better to stick with the default because there are some computations internally in the server that make assumptions about the lease renewal period.

## 11.11 Zones

If you have deployed Eureka clients to multiple zones than you may prefer that those clients leverage services within the same zone before trying services in another zone. To do this you need to configure your Eureka clients correctly.

First, you need to make sure you have Eureka servers deployed to each zone and that they are peers of each other. See the section on[zones and regions](http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi_spring-cloud-eureka-server.html#spring-cloud-eureka-server-zones-and-regions)for more information.

Next you need to tell Eureka which zone your service is in. You can do this using the`metadataMap`property. For example if`service 1`is deployed to both`zone 1`and`zone 2`you would need to set the following Eureka properties in`service 1`

**Service 1 in Zone 1**

    eureka.instance.metadataMap.zone = zone1
    eureka.client.preferSameZoneEureka = true
    

**Service 1 in Zone 2**

    eureka.instance.metadataMap.zone = zone2
    eureka.client.preferSameZoneEureka = true